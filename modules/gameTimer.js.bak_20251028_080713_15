// ============================================================================
// MODULE: gameTimer.js (FULLY SYNCED + STABLE PAUSE/RESUME)
// Purpose: Keeps control + player timers synchronized in real-time via Firestore
// ============================================================================
import { db } from '../../modules/config.js';
import {
  onSnapshot,
  doc,
  serverTimestamp,
  updateDoc,
  getDoc,
  Timestamp
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

let timerInterval = null;
let currentEndTime = null;
let currentRemainingMs = null;

// ---------------------------------------------------------------------------
// ðŸ§­ Format milliseconds into HH:MM:SS
// ---------------------------------------------------------------------------
function formatTime(ms) {
  if (ms == null || isNaN(ms)) return '--:--:--';
  const h = Math.floor(ms / 3_600_000);
  const m = Math.floor((ms % 3_600_000) / 60_000);
  const s = Math.floor((ms % 60_000) / 1000);
  return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
}

// ---------------------------------------------------------------------------
// ðŸ•’ Draw the remaining time continuously
// ---------------------------------------------------------------------------
function getTimerDisplay(selector) {
  if (selector) {
    const el = document.querySelector(selector);
    if (el) return el;
  }
  return document.getElementById('timer-display') ||
    document.getElementById('control-timer-display');
}

function startCountdownTimer(endMs, displaySelector) {
  const display = getTimerDisplay(displaySelector);
  if (!display || !endMs) return;

  clearElapsedTimer();
  currentEndTime = endMs;

  const update = () => {
    const remaining = endMs - Date.now();
    currentRemainingMs = remaining;
    if (remaining <= 0) {
      display.textContent = '00:00:00';
      clearElapsedTimer();
      currentRemainingMs = 0;
      return;
    }
    display.textContent = formatTime(remaining);
  };

  update();
  timerInterval = setInterval(update, 1000);
}

// ---------------------------------------------------------------------------
// ðŸ”¹ Clear interval safely
// ---------------------------------------------------------------------------
export function clearElapsedTimer() {
  if (timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
  }
}

// ---------------------------------------------------------------------------
// â¸ï¸ Pause Game Timer (Control-side)
// ---------------------------------------------------------------------------
export async function pauseGameTimer() {
  try {
    const ref = doc(db, 'game', 'gameState');
    const snap = await getDoc(ref);
    if (!snap.exists()) throw new Error("No gameState document found.");

    const data = snap.data();
    const now = Date.now();

    // Safely compute remaining time
    let remainingMs = 0;
    if (data.endTime?.toMillis) {
      remainingMs = Math.max(data.endTime.toMillis() - now, 0);
    } else if (currentRemainingMs != null) {
      remainingMs = Math.max(currentRemainingMs, 0);
    }

    await updateDoc(ref, {
      status: 'paused',
      remainingMs,
      endTime: null,
      updatedAt: serverTimestamp()
    });

    clearElapsedTimer();
    console.log(`â¸ï¸ Paused with ${Math.floor(remainingMs / 1000)}s left`);
  } catch (err) {
    console.error('âŒ pauseGameTimer error:', err);
  }
}

// ---------------------------------------------------------------------------
// â–¶ï¸ Resume Game Timer (Control-side)
// ---------------------------------------------------------------------------
export async function resumeGameTimer() {
  try {
    const ref = doc(db, 'game', 'gameState');
    const snap = await getDoc(ref);
    if (!snap.exists()) throw new Error("No gameState document found.");

    const data = snap.data();
    const now = Date.now();
    const remainingMs = data.remainingMs ?? currentRemainingMs ?? 0;
    const newEndTime = Timestamp.fromMillis(now + remainingMs);

    await updateDoc(ref, {
      status: 'active',
      endTime: newEndTime,
      remainingMs: null,
      updatedAt: serverTimestamp()
    });

    console.log(`â–¶ï¸ Resumed â€” new endTime = ${newEndTime.toDate().toLocaleTimeString()}`);
  } catch (err) {
    console.error('âŒ resumeGameTimer error:', err);
  }
}

// ---------------------------------------------------------------------------
// ðŸ“¡ Live Sync for All Clients (Control + Player)
// ---------------------------------------------------------------------------
export function listenToGameTimer() {
  const display = getTimerDisplay();
  if (!display) {
    console.warn('â±ï¸ Timer display not found â€” skipping listener init.');
    return;
  }

  const ref = doc(db, 'game', 'gameState');

  onSnapshot(ref, (snap) => {
    const data = snap.data();
    if (!data) return;

    const { status, endTime, startTime, durationMinutes, remainingMs } = data;
    let endMs = null;

    // Compute valid end timestamp
    if (endTime?.toMillis) {
      endMs = endTime.toMillis();
    } else if (startTime?.toMillis && durationMinutes) {
      endMs = startTime.toMillis() + durationMinutes * 60_000;
    } else if (remainingMs) {
      endMs = Date.now() + remainingMs;
    }

    switch (status) {
      case 'active':
        if (endMs) startCountdownTimer(endMs);
        else {
          clearElapsedTimer();
          display.textContent = '--:--:--';
        }
        break;

      case 'paused':
        clearElapsedTimer();
        display.textContent = remainingMs ? formatTime(remainingMs) : '--:--:--';
        break;

      case 'waiting':
        clearElapsedTimer();
        display.textContent = '--:--:--';
        break;

      case 'finished':
      case 'ended':
        clearElapsedTimer();
        display.textContent = '00:00:00';
        break;

      default:
        clearElapsedTimer();
        display.textContent = '--:--:--';
    }

    if (display.id === 'control-timer-display') {
      display.hidden = status === 'waiting';
    }
  });
}
