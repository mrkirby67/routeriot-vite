// ============================================================================
// MODULE: bugStrikeManager.js
// PURPOSE: Manage Bug Strike economy, cooldowns, and Firestore sync
// AUTHOR: Route Riot Dev (James + ChatGPT 2025)
// ============================================================================

import { db } from '../../modules/config.js';
import {
  doc,
  getDoc,
  setDoc,
  updateDoc,
  addDoc,
  collection,
  getDocs,
  serverTimestamp,
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

// ---------------------------------------------------------------------------
// üßÆ Firestore References
// ---------------------------------------------------------------------------
const SETTINGS_REF = doc(db, 'settings', 'bugStrikeSettings');
const STRIKE_COLLECTION = collection(db, 'bugStrikes');
const LOG_COLLECTION = collection(db, 'bugStrikeLog');

// ---------------------------------------------------------------------------
// ü™∞ Load Settings (starting strikes, cooldowns, rewards, etc.)
// ---------------------------------------------------------------------------
export async function getBugStrikeSettings() {
  try {
    const snap = await getDoc(SETTINGS_REF);
    if (snap.exists()) return snap.data();
    return {
      startingStrikes: 3,
      rewardFirstChallenge: 1,
      rewardFirstReclaim: 1,
      rewardEndgame: 1,
      cooldownMinutes: 30,
    };
  } catch (err) {
    console.error("‚ùå Error fetching BugStrike settings:", err);
    return {};
  }
}

// ---------------------------------------------------------------------------
// üß† Initialize Strikes for All Teams
// Called at game start from Control.js
// ---------------------------------------------------------------------------
export async function initializeBugStrikesForTeams(teamNames = []) {
  try {
    const settings = await getBugStrikeSettings();
    const startCount = settings.startingStrikes ?? 0;

    for (const team of teamNames) {
      const teamRef = doc(db, 'bugStrikes', team);
      await setDoc(teamRef, {
        available: startCount,
        used: 0,
        lastUsed: null,
        earnedFrom: [],
        updatedAt: serverTimestamp(),
      });
    }

    console.log(`‚úÖ Initialized Bug Strikes for ${teamNames.length} teams.`);
  } catch (err) {
    console.error("‚ùå Error initializing Bug Strikes:", err);
  }
}

// ---------------------------------------------------------------------------
// üéÅ Grant Strike to a Team (e.g. from a reward trigger)
// ---------------------------------------------------------------------------
export async function grantBugStrike(teamName, source = 'manual') {
  try {
    const teamRef = doc(db, 'bugStrikes', teamName);
    const snap = await getDoc(teamRef);
    const current = snap.exists() ? snap.data() : {};

    const newAvailable = (current.available || 0) + 1;
    await setDoc(teamRef, {
      available: newAvailable,
      used: current.used || 0,
      lastUsed: current.lastUsed || null,
      earnedFrom: [...(current.earnedFrom || []), source],
      updatedAt: serverTimestamp(),
    }, { merge: true });

    await addDoc(LOG_COLLECTION, {
      team: teamName,
      action: 'grant',
      source,
      timestamp: serverTimestamp(),
    });

    console.log(`üéÅ Bug Strike granted to ${teamName} (${source}).`);
  } catch (err) {
    console.error(`‚ùå Failed to grant Bug Strike to ${teamName}:`, err);
  }
}

// ---------------------------------------------------------------------------
// üí• Use Strike (Control-triggered ‚Üí attack another team)
// ---------------------------------------------------------------------------
export async function useBugStrike(fromTeam, targetTeam) {
  try {
    const settings = await getBugStrikeSettings();
    const cooldownMs = (settings.cooldownMinutes ?? 30) * 60000;

    const teamRef = doc(db, 'bugStrikes', fromTeam);
    const snap = await getDoc(teamRef);
    if (!snap.exists()) {
      console.warn(`‚ö†Ô∏è Team ${fromTeam} has no strike data.`);
      return { success: false, reason: 'noData' };
    }

    const data = snap.data();
    const now = Date.now();

    // Cooldown enforcement
    if (data.lastUsed && now - data.lastUsed < cooldownMs) {
      const remaining = Math.ceil((cooldownMs - (now - data.lastUsed)) / 60000);
      return { success: false, reason: `cooldown`, remaining };
    }

    if ((data.available || 0) <= 0) {
      return { success: false, reason: 'noAvailable' };
    }

    // Deduct one & log usage
    await updateDoc(teamRef, {
      available: (data.available || 1) - 1,
      used: (data.used || 0) + 1,
      lastUsed: now,
      updatedAt: serverTimestamp(),
    });

    // Log to global log
    await addDoc(LOG_COLLECTION, {
      from: fromTeam,
      to: targetTeam,
      action: 'use',
      timestamp: serverTimestamp(),
    });

    // Send communication message
    await addDoc(collection(db, 'communications'), {
      teamName: fromTeam,
      sender: fromTeam,
      senderDisplay: fromTeam,
      message: `ü™∞ ${fromTeam} launched a BUG STRIKE on ${targetTeam}! SPLAT!`,
      type: 'bugStrike',
      from: fromTeam,
      to: targetTeam,
      isBroadcast: true,
      timestamp: serverTimestamp(),
    });

    console.log(`üí• Bug Strike launched by ${fromTeam} on ${targetTeam}.`);
    return { success: true };
  } catch (err) {
    console.error(`‚ùå Error using Bug Strike from ${fromTeam}:`, err);
    return { success: false, reason: 'error' };
  }
}

// ---------------------------------------------------------------------------
// üßπ Reset All Bug Strikes (e.g., when game is reset)
// ---------------------------------------------------------------------------
export async function resetBugStrikes() {
  try {
    const snap = await getDocs(STRIKE_COLLECTION);
    for (const docSnap of snap.docs) {
      await updateDoc(docSnap.ref, {
        available: 0,
        used: 0,
        lastUsed: null,
        earnedFrom: [],
        updatedAt: serverTimestamp(),
      });
    }
    console.log('üßπ All Bug Strikes reset.');
  } catch (err) {
    console.error('‚ùå Failed to reset Bug Strikes:', err);
  }
}

// ---------------------------------------------------------------------------
// üìä Utility: Get Summary of All Teams (for Control display)
// ---------------------------------------------------------------------------
export async function getAllBugStrikeData() {
  const snap = await getDocs(STRIKE_COLLECTION);
  const teams = [];
  snap.forEach(docSnap => {
    teams.push({ team: docSnap.id, ...docSnap.data() });
  });
  return teams;
}
