// ============================================================================ 
// MODULE 1: gameRulesManager.js
// Purpose: Handles loading, editing, and saving Route Riot game rules.
// ============================================================================ 
import { app, db, firebaseConfig } from './config.js';
import {
  doc,
  getDoc,
  setDoc,
  collection,
  getDocs,
  deleteDoc,
  writeBatch,
  addDoc,
  Timestamp,
  serverTimestamp,
  onSnapshot
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
import { clearAllTeamSurprises } from './teamSurpriseManager.js';

export async function loadRules(rulesTextArea) {
  const rulesDocRef = doc(db, 'settings', 'rules');
  const snap = await getDoc(rulesDocRef);
  rulesTextArea.value = snap.exists() 
    ? (snap.data().content || '') 
    : 'Enter your Route Riot rules here...';
}

export async function saveRules(rulesTextArea) {
  const rulesDocRef = doc(db, 'settings', 'rules');
  await setDoc(rulesDocRef, { content: rulesTextArea.value.trim() }, { merge: true });
  // Replace blocking alert with inline UI feedback if preferred
  alert('‚úÖ Rules saved!');
}

export function toggleRules(rulesSection, toggleButton) {
  const open = rulesSection.style.display !== 'none';
  rulesSection.style.display = open ? 'none' : 'block';
  toggleButton.textContent = open ? 'üìú Edit Rules' : '‚ùå Close Rules';
}

// ============================================================================
// MODULE 2: gameTimer.js
// Purpose: Handles real-time countdown display for active games.
// ============================================================================
export function initializeGameTimer(timerDisplay) {
  const gameDocRef = doc(db, 'game', 'gameState');
  let gameTimerInterval;

  onSnapshot(gameDocRef, (docSnap) => {
    if (gameTimerInterval) clearInterval(gameTimerInterval);
    const gs = docSnap.data();

    if (gs && gs.status === 'active' && gs.endTime) {
      const endMs = gs.endTime?.toMillis ? gs.endTime.toMillis() : gs.endTime;

      gameTimerInterval = setInterval(() => {
        const remaining = endMs - Date.now();
        if (remaining <= 0) {
          timerDisplay.textContent = '00:00:00';
          clearInterval(gameTimerInterval);
        } else {
          const h = Math.floor((remaining / 3_600_000) % 24);
          const m = Math.floor((remaining / 60_000) % 60);
          const s = Math.floor((remaining / 1_000) % 60);
          timerDisplay.textContent = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        }
      }, 1000);
    } else {
      timerDisplay.textContent = '--:--:--';
    }
  });
}

// ============================================================================ 
// MODULE 3: teamManager.js
// Purpose: Randomizes teams and sends player emails.
// ============================================================================ 
import { allTeams } from '../data.js';
import { emailAllTeams } from './emailTeams.js';

export async function randomizeTeams(teamSize = 2) {
  const snap = await getDocs(collection(db, 'racers'));
  const racers = snap.docs.map(d => ({ id: d.id, ...d.data() })).filter(r => r.name);

  if (racers.length === 0) {
    alert('‚ö†Ô∏è No racers found in Firestore.');
    return;
  }

  // Shuffle racers
  for (let i = racers.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [racers[i], racers[j]] = [racers[j], racers[i]];
  }

  // Assign teams
  const batch = writeBatch(db);
  racers.forEach((r, i) => {
    const tIndex = Math.floor(i / teamSize);
    const team = allTeams[tIndex % allTeams.length];
    batch.set(doc(db, 'racers', r.id), { team: team.name }, { merge: true });
  });

  await batch.commit();
  alert(`üé≤ ${Math.ceil(racers.length / teamSize)} teams randomized!`);
}

export async function emailTeams(rulesDocRef) {
  const racersSnap = await getDocs(collection(db, 'racers'));
  const racers = racersSnap.docs.map(d => d.data());
  const activeTeams = {};

  racers.forEach(r => {
    if (r.team && r.team !== '-' && r.email) {
      if (!activeTeams[r.team]) activeTeams[r.team] = [];
      activeTeams[r.team].push(r);
    }
  });

  const teamNames = Object.keys(activeTeams);
  if (teamNames.length === 0) {
    alert(`‚ùå No racers assigned to teams yet.
Please randomize teams first.`);
    return;
  }

  await setDoc(doc(db, 'game', 'gameState'), { zonesReleased: true }, { merge: true });
  await setDoc(doc(db, 'game', 'activeTeams'), { list: teamNames }, { merge: true });

  const rulesSnap = await getDoc(rulesDocRef);
  const currentRules = rulesSnap.exists() ? rulesSnap.data().content : '';

  if (confirm(`Email links to ${teamNames.length} active teams now?`)) {
    emailAllTeams(currentRules, activeTeams);
    alert(`üìß Emails prepared for ${teamNames.length} active teams.
Check your Gmail tabs.`);
  }
}

// ============================================================================
// MODULE 4: gameStateManager.js
// Purpose: Handles start, pause, and end states of the game.
// ============================================================================
export async function startGame(gameDuration = 120) {
  const mins = Number(gameDuration) || 120;
  const endTime = Timestamp.fromMillis(Date.now() + mins * 60 * 1000);

  const racersSnap = await getDocs(collection(db, 'racers'));
  const teamsInPlay = new Set();
  racersSnap.forEach(d => {
    const r = d.data();
    if (r.team && r.team !== '-') teamsInPlay.add(r.team);
  });

  await setDoc(doc(db, 'game', 'activeTeams'), { list: Array.from(teamsInPlay) }, { merge: true });
  await setDoc(doc(db, 'game', 'gameState'), {
    status: 'active',
    startTime: serverTimestamp(),
    endTime,
    zonesReleased: true,
    dataVersion: Date.now()
  }, { merge: true });

  await addDoc(collection(db, 'communications'), {
    teamName: 'Game Master',
    sender: 'Game Master',
    senderDisplay: 'Game Master',
    message: 'üèÅ The race has begun! Zones are now active ‚Äî good luck racers!',
    timestamp: serverTimestamp()
  });

  alert(`üèÅ Game Started ‚Äî Zones Released!
${teamsInPlay.size} teams active.`);
}

export async function pauseGame() {
  await setDoc(doc(db, 'game', 'gameState'), { status: 'paused' }, { merge: true });
  alert('‚è∏Ô∏è Game Paused!');
}

export async function endGame() {
  try {
    await setDoc(doc(db, 'game', 'gameState'), { status: 'finished' }, { merge: true });

    const scoresSnap = await getDocs(collection(db, 'scores'));
    const scores = scoresSnap.docs
      .map(d => ({ team: d.id, ...d.data() }))
      .filter(s => typeof s.score === 'number')
      .sort((a, b) => b.score - a.score);

    if (scores.length === 0) {
      await addDoc(collection(db, 'communications'), {
        teamName: 'Game Master',
        sender: 'Game Master',
        senderDisplay: 'Game Master',
        message: 'üèÅ Game Ended ‚Äî No scores found.',
        timestamp: serverTimestamp()
      });
      alert('Game Ended ‚Äî no scores recorded.');
      return;
    }

    const medals = ['ü•á 1st Place', 'ü•à 2nd Place', 'ü•â 3rd Place'];
    const lines = scores.slice(0, 3).map((s, i) => `${medals[i]} ‚Äî ${s.team} (${s.score} pts)`);

    await addDoc(collection(db, 'communications'), {
      teamName: 'Game Master',
      sender: 'Game Master',
      senderDisplay: 'Game Master',
      message: `üèÅ FINAL STANDINGS üèÅ\n\n${lines.join('\n')}\n\n‚Äî Route Riot Control`,
      timestamp: serverTimestamp()
    });

    alert('üèÅ Game Ended ‚Äî Winners broadcasted!');
  } catch (err) {
    console.error('End Game error:', err);
    alert('Error ending game ‚Äî see console.');
  }
}

// ============================================================================
// MODULE 5: gameMaintenance.js
// Purpose: Handles resets, wipes, and maintenance tasks.
// ============================================================================
export async function resetFullGame() {
  await clearGameSideEffects();
  if (!confirm('ARE YOU SURE?\nThis will permanently delete all game data.')) return;
  alert('Resetting game data...');

  try {
    const batch = writeBatch(db);
    batch.set(doc(db, 'game', 'gameState'), {
      status: 'not started',
      zonesReleased: false,
      dataVersion: Date.now()
    });
    batch.delete(doc(db, 'game', 'activeTeams'));

    const racers = await getDocs(collection(db, 'racers'));
    racers.forEach(r => batch.set(r.ref, { team: '-' }, { merge: true }));

    const zones = await getDocs(collection(db, 'zones'));
    zones.forEach(z => batch.set(z.ref, { status: 'Available', controllingTeam: '' }, { merge: true }));

    const scores = await getDocs(collection(db, 'scores'));
    scores.forEach(s => batch.delete(s.ref));

    await batch.commit();
    alert('‚úÖ Game has been reset.');
  } catch (err) {
    console.error('Reset error:', err);
    alert('An error occurred while resetting. Check console.');
  }
}

async function clearGameSideEffects() {
  const flatTireCol = collection(db, 'flatTireAssignments');
  const speedBumpCol = collection(db, 'speedBumpAssignments');

  async function wipe(col) {
    const snap = await getDocs(col);
    for (const docSnap of snap.docs) {
      await deleteDoc(docSnap.ref);
    }
  }

  await wipe(flatTireCol);
  await wipe(speedBumpCol);

  // Reset shields / cooldowns / traps / wildcards
  await clearAllTeamSurprises();
}

/**
 * Clear all tracked game collections and restore the default state.
 * Intended for emergency resets where a completely fresh slate is required.
 */
export async function clearAllCollectionsAndReset() {
  const { collection, getDocs, deleteDoc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
  const { db } = await import("./config.js");
  const { resetGameState } = await import("./gameStateManager.js");
  const { showFlashMessage } = await import("./gameUI.js");

  const targets = [
    "communications",
    "conversations",
    "flatTireAssignments",
    "game",
    "racers",
    "scores",
    "settings",
    "speedBumpAssignments",
    "surpriseAudit",
    "teamStatus",
    "teamSurprises",
    "zones",
  ];

  showFlashMessage("üßπ Clearing Firestore collections...");

  try {
    for (const colName of targets) {
      const snap = await getDocs(collection(db, colName));
      const deletions = [];
      snap.forEach((docSnap) => deletions.push(deleteDoc(docSnap.ref)));
      if (deletions.length > 0) {
        await Promise.allSettled(deletions);
      }
      console.log(`‚úÖ Cleared ${colName} (${deletions.length} docs)`);
    }

    await resetGameState();
    showFlashMessage("‚úÖ All collections cleared and game reset.");
  } catch (err) {
    console.error("‚ùå clearAllCollectionsAndReset failed:", err);
    showFlashMessage("‚ö†Ô∏è Reset failed ‚Äì see console for details.");
  }
}
