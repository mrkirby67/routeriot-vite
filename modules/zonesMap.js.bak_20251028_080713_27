// ============================================================================
// FILE: /modules/zonesMap.js
// PURPOSE: Static map and geometry encoding helpers for mini-map previews
// ============================================================================

import { firebaseConfig } from '../../modules/config.js';

const FALLBACK_DIAMETER_KM = 0.05;

// ---------------------------------------------------------------------------
// üó∫Ô∏è Calculate Zoom Level (shared across Flat Tire + Zone Management)
// ---------------------------------------------------------------------------
export function calculateZoomFromDiameter(diameterKm) {
  const numeric = parseFloat(diameterKm);
  const safe = Number.isFinite(numeric) && numeric > 0 ? numeric : FALLBACK_DIAMETER_KM;
  return Math.max(3, Math.min(21, Math.round(16 - Math.log2(safe))));
}

// Backwards compatibility helper (kept for legacy imports)
export function calculateZoomLevel(diameterKm, _imageWidthPixels = 150) {
  return calculateZoomFromDiameter(diameterKm);
}

// ---------------------------------------------------------------------------
// üß≠ Encode Circle (for drawing circular zone boundaries on static maps)
// ---------------------------------------------------------------------------
export function encodeCircle(centerStr, radiusMeters = 50) {
  try {
    if (!centerStr) return { mode: 'none', value: '' };

    const [lat, lng] = centerStr.split(',').map(Number);
    if (Number.isNaN(lat) || Number.isNaN(lng)) {
      return { mode: 'none', value: '' };
    }

    const hasGoogleGeometry =
      typeof window !== 'undefined' &&
      window.google?.maps?.geometry?.encoding &&
      window.google?.maps?.LatLng;

    if (hasGoogleGeometry) {
      const points = buildCirclePathPoints(lat, lng, radiusMeters);
      const encoded = window.google.maps.geometry.encoding.encodePath(
        points.map(([pLat, pLng]) => new window.google.maps.LatLng(pLat, pLng))
      );
      return encoded ? { mode: 'encoded', value: encoded } : { mode: 'none', value: '' };
    }

    const fallbackPoints = buildCirclePathPoints(lat, lng, radiusMeters);
    return fallbackPoints.length
      ? { mode: 'points', value: fallbackPoints }
      : { mode: 'none', value: '' };
  } catch (err) {
    console.warn('‚ö†Ô∏è encodeCircle failed:', err);
    return { mode: 'none', value: '' };
  }
}

function buildCirclePathPoints(lat, lng, radiusMeters = 50, stepDegrees = 12) {
  const R = 6371e3; // metres
  const points = [];
  const latRad = (lat * Math.PI) / 180;
  const lngRad = (lng * Math.PI) / 180;
  const angularDistance = radiusMeters / R;

  for (let degrees = 0; degrees <= 360; degrees += stepDegrees) {
    const bearing = (degrees * Math.PI) / 180;
    const lat2 = Math.asin(
      Math.sin(latRad) * Math.cos(angularDistance) +
      Math.cos(latRad) * Math.sin(angularDistance) * Math.cos(bearing)
    );
    const lng2 =
      lngRad +
      Math.atan2(
        Math.sin(bearing) * Math.sin(angularDistance) * Math.cos(latRad),
        Math.cos(angularDistance) - Math.sin(latRad) * Math.sin(lat2)
      );

    points.push([lat2 * 180 / Math.PI, lng2 * 180 / Math.PI]);
  }

  return points;
}

// ---------------------------------------------------------------------------
// üß© Generate Mini Map (Static Map thumbnail for Control & Player views)
// ---------------------------------------------------------------------------
export function generateMiniMap(zoneData = {}) {
  if (!firebaseConfig?.apiKey) {
    return `<img src="https://placehold.co/150x150/5d1c1c/ffffff?text=Missing+API+Key" class="mini-map" alt="No API key configured">`;
  }

  const gpsRegex = /^-?\d+(\.\d+)?,\s*-?\d+(\.\d+)?$/;
  if (!zoneData.gps || !gpsRegex.test(zoneData.gps)) {
    return `<img src="https://placehold.co/150x150/1e1e1e/999?text=Invalid+GPS" class="mini-map" alt="Invalid GPS data">`;
  }

  const [lat, lng] = zoneData.gps.split(',').map(n => parseFloat(n.trim()));
  const diameterKm = parseFloat(zoneData.diameter) || FALLBACK_DIAMETER_KM;
  const zoomLevel = calculateZoomFromDiameter(diameterKm);
  const captureRadius = Number(zoneData.captureRadiusMeters);
  const radiusMeters = Number.isFinite(captureRadius) && captureRadius > 0
    ? captureRadius
    : Math.max((diameterKm / 2) * 1000, 5);

  // Build Static Map URL
  const mapUrl = new URL('https://maps.googleapis.com/maps/api/staticmap');
  mapUrl.searchParams.set('center', `${lat},${lng}`);
  mapUrl.searchParams.set('zoom', zoomLevel);
  mapUrl.searchParams.set('size', '150x150');
  mapUrl.searchParams.set('maptype', 'satellite');
  mapUrl.searchParams.set('markers', `color:red|${lat},${lng}`);
  mapUrl.searchParams.set('key', firebaseConfig.apiKey);

  // Optional overlay circle via encoded or point-based path
  try {
    const circle = encodeCircle(`${lat},${lng}`, radiusMeters);
    if (circle.mode === 'encoded' && circle.value) {
      mapUrl.searchParams.append(
        'path',
        `color:0xFF980080|weight:2|fillcolor:0xFF980020|enc:${circle.value}`
      );
    } else if (circle.mode === 'points' && circle.value?.length) {
      const pathPoints = circle.value.map(([pLat, pLng]) => `${pLat},${pLng}`).join('|');
      mapUrl.searchParams.append(
        'path',
        `color:0xFF980080|weight:2|fillcolor:0xFF980020|${pathPoints}`
      );
    }
  } catch (err) {
    console.warn('‚ö†Ô∏è Could not encode circle:', err);
  }

  const label = zoneData.name || 'Zone';
  return `<img src="${mapUrl.toString()}" class="mini-map" alt="Map preview of ${label}">`;
}
